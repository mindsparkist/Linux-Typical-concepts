# Linux-Typical-concepts
3 - Interrupt the Boot Process to Gain Access to a System
https://onedrive.live.com/view?id=758D23B2E6014B79!479&resid=758D23B2E6014B79!479&authkey=!APLrE40SPxIsN8c&wdAccPdf=0&wdEmbedFS=1&wdo=2&cid=758d23b2e6014b79

4 - Identify CPUMemory Intensive Processes, Adjust Process Priority and Kill Processes - Part 1

# Linux Concept

The `pgrep` command in Linux is a handy tool for finding the process IDs (PIDs) of running processes based on specific criteria. It's like `grep` for processes, hence the name "pgrep".

Here's a breakdown of what `pgrep` does and how to use it:

**What it does:**

* Searches for running processes based on process name, owner, and other attributes.
* Returns a list of PIDs matching the search criteria.

**How to use it:**

* Basic syntax: `pgrep [options] process_name`

**Common options:**

* `-u username`: Find processes owned by a specific user.
* `-f exact_name`: Find processes with an exact name match. (default is partial match)
* `-c`: Count the number of matching processes instead of listing PIDs.
* `-l`:  List process names along with their PIDs.

**Examples:**

* Find all processes named `bash`: `pgrep bash`
* Find processes owned by the user `root`: `pgrep -u root`
* Find the exact process named `firefox`: `pgrep -f firefox`
* Count the number of `chrome` processes: `pgrep -c chrome`
* List PIDs and names of all `apache2` processes: `pgrep -l apache2`

**Additional Tips:**

* You can use `pgrep` in conjunction with other commands for automation. For example, you can pipe the output of `pgrep` to `pkill` to send a signal (like terminate) to those processes.
* Use `man pgrep` for more detailed information and options.

By using `pgrep`, you can efficiently identify and manage running processes on your Linux system.

Both `kill` and `pkill` commands are used to terminate processes in Linux, but they differ in how they target the processes they terminate:

**kill:**

* **Terminates by PID:**  `kill` targets processes by their **Process ID (PID)**.  You need to know the exact PID of the process you want to terminate.
* **Generic Signal:** By default, `kill` sends a **SIGTERM (terminate)** signal to the process. This signal instructs the process to shut down gracefully, allowing it to clean up any resources it's holding before exiting.
* **Can Terminate Any Process:** You can use `kill` with various signal options to send different signals to the process, including forceful termination with `SIGKILL`.


**pkill:**

* **Terminates by Name:**  `pkill` targets processes by their **name (or partial name)**. This is more convenient than remembering PIDs, especially if you have multiple instances of a process running.
* **Wildcard Matching:** `pkill` supports wildcard characters like `*` for broader matching. For example, `pkill firefox` would terminate all processes whose names start with "firefox."
* **Limited Signal Options:** By default, `pkill` also sends a SIGTERM signal to the processes it finds. It typically doesn't offer the same level of control over signal options as `kill`.


Here's a table summarizing the key differences:

| Feature        | kill          | pkill           |
|----------------|----------------|-----------------|
| Target Method   | Process ID (PID) | Process Name      |
| Wildcards      | Not Supported   | Supported        |
| Default Signal | SIGTERM         | SIGTERM         |
| Signal Options | More Flexible   | Limited          |


**Choosing the Right Tool:**

* Use `kill` when you know the exact PID of the process you want to terminate and potentially need to send a specific signal.
* Use `pkill` when you want to terminate processes based on their name (or partial name) and a SIGTERM is sufficient.

**Examples:**

* Terminate a process with PID 1234:

```bash
kill 1234
```

* Terminate all Firefox processes:

```bash
pkill firefox
```

* Terminate all processes starting with "chrome":

```bash
pkill -f chrome*
```

By understanding these distinctions, you can effectively target and terminate processes in your Linux system using either `kill` or `pkill` depending on your specific needs.

There are many signals used in Linux (including RHEL) to communicate with processes, but a few  are particularly noteworthy when it comes to terminating or otherwise controlling processes. Here are some of the main kill signals used in Linux (RHEL):

* **SIGTERM (15)**: This is the most common and preferred way to terminate a process gracefully. By default, the `kill` command sends SIGTERM to a process.  When a process receives SIGTERM, it has a chance to clean up any resources it's holding before exiting.

* **SIGINT (2)**: This signal is typically generated by pressing Ctrl+C on the keyboard. It instructs the process to interrupt its current operation and terminate.  While it works for many processes,  it may not allow for proper cleanup.

* **SIGKILL (9)**: This signal is used for forceful termination of a process.  A process that receives SIGKILL cannot ignore it and will be immediately terminated without any chance to clean up resources.  This should be used as a last resort as it can lead to data loss or system instability.

The `w` command in Linux is used to display information about the users who are currently logged in and their activities. When you run the `w` command, it typically outputs a list of users currently logged in, along with details such as their username, terminal, login time, idle time, and what command they are currently running, if any.

Here's a typical example of the output of the `w` command:

```
 17:23:45 up 10 days,  3:27,  5 users,  load average: 0.52, 0.25, 0.18
USER     TTY      FROM             LOGIN@   IDLE   JCPU   PCPU WHAT
user1    tty1                      Mon10    4days  0.00s  0.00s -bash
user2    tty2                      Mon12    1:24m  0.18s  0.18s top
user3    pts/0    :0.0             13:45    3:20   0.00s  0.00s bash
```

Here's a breakdown of the columns:

- **USER**: The username of the logged-in user.
- **TTY**: The terminal name or "pts" (pseudo terminal slave) for remote connections.
- **FROM**: The hostname or IP address from which the user is logged in.
- **LOGIN@**: The time the user logged in.
- **IDLE**: How long the user has been idle.
- **JCPU**: The total CPU time used by the user's job(s).
- **PCPU**: The CPU time used by the user's current process.
- **WHAT**: The command being executed by the user.

The `w` command is useful for administrators to monitor user activity on a system, see who is currently logged in, and what they are doing.

* **SIGHUP (1)**: This signal is sent to a process when its controlling terminal is disconnected. It's  commonly used to trigger a process to reread its configuration file.


These are just a few of the important kill signals used in Linux. You can find a comprehensive list of signals and their descriptions using the `man 7 signal` command.

Here's how you can create a process, send it to the background, stop it, and start it again in RHEL:

**1. Creating a Process:**

Let's use the `sleep` command as an example process. This command simply pauses execution for a specified time. You can replace it with any other command you want to run.

```bash
# This command sleeps for 10 seconds
sleep 10
```

**2. Sending the Process to the Background:**

There are two ways to send the process to the background:

* **Using the `&` symbol:** Append an ampersand (`&`) symbol to the end of the command when you run it. This tells the shell to run the command in the background and return control to you immediately.

```bash
sleep 10 &
```

* **Using `bg` after starting the process:** If you forget the `&` symbol initially, you can use the `bg` command to send an already running process in the foreground to the background.

```bash
sleep 10
# Press Ctrl+Z to suspend the process
bg
```

**3. Checking Background Jobs:**

You can use the `jobs` command to view a list of your background jobs. This will display the job ID and the command associated with it.

```bash
jobs
```

**4. Stopping the Process:**

To stop a background process, you can use the `kill` command followed by the job ID obtained from the `jobs` command.

```bash
jobs
# Output will be similar to:
# [1] (running) sleep 10 &

# Get the job ID (in this case, 1)
kill %1
```

**5. Starting the Process Again:**

There are two ways to start a background process again, depending on the command used to stop it:

* **If stopped with `Ctrl+Z`:** Use the `fg` command followed by the job ID to bring the process back to the foreground and resume execution.

```bash
jobs
# Get the job ID (e.g., 1)
fg %1
```

* **If stopped with `kill`:** Unfortunately, `kill` typically terminates the process completely.  You'll need to restart the process by running the original command again.

```bash
# This will start a new instance of the sleep command
sleep 10 &
```

**Remember:**

* Be cautious when using `kill` as it can lead to data loss for some processes.
* Make sure to replace `sleep 10` with the actual command you want to run in the background.

In Linux, the `nice` and `renice` commands come in handy for managing process priorities, affecting how much CPU time they receive. Here's a breakdown of what they do and how they can be useful:

**Nice Command**

* **Function:** Launches a new process with a specific priority (niceness value).
* **Niceness Value:**  Lower values indicate higher priority (more CPU time), while higher values indicate lower priority (less CPU time). Valid range is typically -20 (highest) to 19 (lowest).  **Note:** Root users can set negative niceness for even higher priority, but this should be used cautiously.
* **Practical Uses:**
    * **Background Tasks:**  Run low-priority tasks like system backups or log processing without impacting interactive use by setting a higher niceness value.
    * **Long-running Processes:** Give priority to critical processes by launching them with a lower niceness value.

**Renice Command**

* **Function:** Modifies the priority of an already running process.
* **Niceness Value:** Similar to `nice`, use a lower value for higher priority and a higher value for lower priority.
* **Practical Uses:**
    * **Adjusting Priorities:** If a background task is taking too long, you can use `renice` to increase its niceness value, giving more CPU time to other processes.
    * **Fine-tuning Resource Allocation:** System administrators can use `renice` to manage resource usage for specific processes based on their importance.

**Important Considerations:**

* **Normal Users and Priority:**  Regular users can only adjust priorities **down** (higher niceness value).  Raising a process's priority (lower niceness) typically requires root access.
* **Impact on Performance:**  While `nice` and `renice` can influence process speeds, other factors like system load and available resources also play a role.


**Examples:**

* **Run `make` with lower priority:** `nice make` (gives `make` a higher niceness value)
* **Increase priority of a process with PID 1234:** `renice -n 5 -p 1234` (sets niceness to 5 for process 1234)


By effectively using `nice` and `renice`, you can optimize process scheduling and ensure critical tasks receive the resources they need while keeping your Linux system responsive.

Link = https://www.youtube.com/watch?v=kmk3_kEiJvk&pp=ygUUbmljZSByZW5pY2UgaW4gbGludXg%3D

The `uptime` command in Linux displays the current time, how long the system has been running, the number of users currently logged in, and the system load averages for the past 1, 5, and 15 minutes.

When you run the `uptime` command, you'll typically see output like this:

```
 17:23:45 up 10 days,  3:27,  5 users,  load average: 0.52, 0.25, 0.18
```

Here's a breakdown of the information provided:

- **17:23:45**: Current time.
- **up 10 days, 3:27**: Time since the system was last booted. In this example, it's been up for 10 days and 3 hours and 27 minutes.
- **5 users**: The number of users currently logged in to the system.
- **load average**: The load average represents the average number of processes waiting to run over the last 1, 5, and 15 minutes, respectively. In the example, the load averages are 0.52, 0.25, and 0.18.

The load averages give you an idea of how busy the system has been over the specified time periods. High load averages could indicate that the system is under heavy load, while low load averages suggest the system is relatively idle.

The `uptime` command is handy for quickly checking how long a Linux system has been running and its current load status.

## You can check CPU info using 

```
cat /proc/cpuinfo
```
## You can check number of CPU processors. It will give you a number

```
 cat /proc/cpuinfo | grep "model name" | wc -l
```
to check average load in the cpu 
![Avg Load](https://github.com/mindsparkist/Linux-Typical-concepts/blob/3---Interrupt-the-Boot-Process-to-Gain-Access-to-a-System/Screenshot%202024-04-11%20085208.png?raw=true)


Divide Load from uptime by number of CPU processors.

Attaching Img


