# Linux-Typical-concepts
3 - Interrupt the Boot Process to Gain Access to a System

# Linux Concept

The `pgrep` command in Linux is a handy tool for finding the process IDs (PIDs) of running processes based on specific criteria. It's like `grep` for processes, hence the name "pgrep".

Here's a breakdown of what `pgrep` does and how to use it:

**What it does:**

* Searches for running processes based on process name, owner, and other attributes.
* Returns a list of PIDs matching the search criteria.

**How to use it:**

* Basic syntax: `pgrep [options] process_name`

**Common options:**

* `-u username`: Find processes owned by a specific user.
* `-f exact_name`: Find processes with an exact name match. (default is partial match)
* `-c`: Count the number of matching processes instead of listing PIDs.
* `-l`:  List process names along with their PIDs.

**Examples:**

* Find all processes named `bash`: `pgrep bash`
* Find processes owned by the user `root`: `pgrep -u root`
* Find the exact process named `firefox`: `pgrep -f firefox`
* Count the number of `chrome` processes: `pgrep -c chrome`
* List PIDs and names of all `apache2` processes: `pgrep -l apache2`

**Additional Tips:**

* You can use `pgrep` in conjunction with other commands for automation. For example, you can pipe the output of `pgrep` to `pkill` to send a signal (like terminate) to those processes.
* Use `man pgrep` for more detailed information and options.

By using `pgrep`, you can efficiently identify and manage running processes on your Linux system.

Both `kill` and `pkill` commands are used to terminate processes in Linux, but they differ in how they target the processes they terminate:

**kill:**

* **Terminates by PID:**  `kill` targets processes by their **Process ID (PID)**.  You need to know the exact PID of the process you want to terminate.
* **Generic Signal:** By default, `kill` sends a **SIGTERM (terminate)** signal to the process. This signal instructs the process to shut down gracefully, allowing it to clean up any resources it's holding before exiting.
* **Can Terminate Any Process:** You can use `kill` with various signal options to send different signals to the process, including forceful termination with `SIGKILL`.


**pkill:**

* **Terminates by Name:**  `pkill` targets processes by their **name (or partial name)**. This is more convenient than remembering PIDs, especially if you have multiple instances of a process running.
* **Wildcard Matching:** `pkill` supports wildcard characters like `*` for broader matching. For example, `pkill firefox` would terminate all processes whose names start with "firefox."
* **Limited Signal Options:** By default, `pkill` also sends a SIGTERM signal to the processes it finds. It typically doesn't offer the same level of control over signal options as `kill`.


Here's a table summarizing the key differences:

| Feature        | kill          | pkill           |
|----------------|----------------|-----------------|
| Target Method   | Process ID (PID) | Process Name      |
| Wildcards      | Not Supported   | Supported        |
| Default Signal | SIGTERM         | SIGTERM         |
| Signal Options | More Flexible   | Limited          |


**Choosing the Right Tool:**

* Use `kill` when you know the exact PID of the process you want to terminate and potentially need to send a specific signal.
* Use `pkill` when you want to terminate processes based on their name (or partial name) and a SIGTERM is sufficient.

**Examples:**

* Terminate a process with PID 1234:

```bash
kill 1234
```

* Terminate all Firefox processes:

```bash
pkill firefox
```

* Terminate all processes starting with "chrome":

```bash
pkill -f chrome*
```

By understanding these distinctions, you can effectively target and terminate processes in your Linux system using either `kill` or `pkill` depending on your specific needs.

There are many signals used in Linux (including RHEL) to communicate with processes, but a few  are particularly noteworthy when it comes to terminating or otherwise controlling processes. Here are some of the main kill signals used in Linux (RHEL):

* **SIGTERM (15)**: This is the most common and preferred way to terminate a process gracefully. By default, the `kill` command sends SIGTERM to a process.  When a process receives SIGTERM, it has a chance to clean up any resources it's holding before exiting.

* **SIGINT (2)**: This signal is typically generated by pressing Ctrl+C on the keyboard. It instructs the process to interrupt its current operation and terminate.  While it works for many processes,  it may not allow for proper cleanup.

* **SIGKILL (9)**: This signal is used for forceful termination of a process.  A process that receives SIGKILL cannot ignore it and will be immediately terminated without any chance to clean up resources.  This should be used as a last resort as it can lead to data loss or system instability.

The `w` command in Linux is used to display information about the users who are currently logged in and their activities. When you run the `w` command, it typically outputs a list of users currently logged in, along with details such as their username, terminal, login time, idle time, and what command they are currently running, if any.

Here's a typical example of the output of the `w` command:

```
 17:23:45 up 10 days,  3:27,  5 users,  load average: 0.52, 0.25, 0.18
USER     TTY      FROM             LOGIN@   IDLE   JCPU   PCPU WHAT
user1    tty1                      Mon10    4days  0.00s  0.00s -bash
user2    tty2                      Mon12    1:24m  0.18s  0.18s top
user3    pts/0    :0.0             13:45    3:20   0.00s  0.00s bash
```

Here's a breakdown of the columns:

- **USER**: The username of the logged-in user.
- **TTY**: The terminal name or "pts" (pseudo terminal slave) for remote connections.
- **FROM**: The hostname or IP address from which the user is logged in.
- **LOGIN@**: The time the user logged in.
- **IDLE**: How long the user has been idle.
- **JCPU**: The total CPU time used by the user's job(s).
- **PCPU**: The CPU time used by the user's current process.
- **WHAT**: The command being executed by the user.

The `w` command is useful for administrators to monitor user activity on a system, see who is currently logged in, and what they are doing.

* **SIGHUP (1)**: This signal is sent to a process when its controlling terminal is disconnected. It's  commonly used to trigger a process to reread its configuration file.


These are just a few of the important kill signals used in Linux. You can find a comprehensive list of signals and their descriptions using the `man 7 signal` command.

Here's how you can create a process, send it to the background, stop it, and start it again in RHEL:

**1. Creating a Process:**

Let's use the `sleep` command as an example process. This command simply pauses execution for a specified time. You can replace it with any other command you want to run.

```bash
# This command sleeps for 10 seconds
sleep 10
```

**2. Sending the Process to the Background:**

There are two ways to send the process to the background:

* **Using the `&` symbol:** Append an ampersand (`&`) symbol to the end of the command when you run it. This tells the shell to run the command in the background and return control to you immediately.

```bash
sleep 10 &
```

* **Using `bg` after starting the process:** If you forget the `&` symbol initially, you can use the `bg` command to send an already running process in the foreground to the background.

```bash
sleep 10
# Press Ctrl+Z to suspend the process
bg
```

**3. Checking Background Jobs:**

You can use the `jobs` command to view a list of your background jobs. This will display the job ID and the command associated with it.

```bash
jobs
```

**4. Stopping the Process:**

To stop a background process, you can use the `kill` command followed by the job ID obtained from the `jobs` command.

```bash
jobs
# Output will be similar to:
# [1] (running) sleep 10 &

# Get the job ID (in this case, 1)
kill %1
```

**5. Starting the Process Again:**

There are two ways to start a background process again, depending on the command used to stop it:

* **If stopped with `Ctrl+Z`:** Use the `fg` command followed by the job ID to bring the process back to the foreground and resume execution.

```bash
jobs
# Get the job ID (e.g., 1)
fg %1
```

* **If stopped with `kill`:** Unfortunately, `kill` typically terminates the process completely.  You'll need to restart the process by running the original command again.

```bash
# This will start a new instance of the sleep command
sleep 10 &
```

**Remember:**

* Be cautious when using `kill` as it can lead to data loss for some processes.
* Make sure to replace `sleep 10` with the actual command you want to run in the background.

